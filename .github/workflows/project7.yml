name: Project 7

on:
  workflow_dispatch:
  push:
    paths: ".github/workflows/project7.yml"

env:
  TARGET_REPO: imjac0b/${{ secrets.PROJECT_7_REPO }}
  TARGET_BASE_URL_ROOT: ${{ secrets.PROJECT_7_URL }}
  ARTIFACT_PATTERN: app-*
  DEVELOPER_NAME: ${{ secrets.PROJECT_7_DEVELOPER_NAME }}
  SOURCE_JSON_BASE: ${{ secrets.PROJECT_7_SOURCE_JSON_BASE }}

jobs:
  build:
    name: Build ${{ matrix.app }}
    runs-on: macos-26
    strategy:
      fail-fast: false
      matrix:
        include:
          - app: Verse
            repo: imjac0b/verse
            scheme: Verse
          
          - app: Extension
            repo: imjac0b/chrome-extension
            scheme: "Jacob (iOS)"
            subdir: Jacob
            setup: bun install --silent --frozen-lockfile && bun build:safari

    steps:
      - name: Checkout App Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          fetch-depth: 1
          token: ${{ secrets.PROJECT_7_TOKEN }}

      - name: Setup Bun
        if: contains(matrix.setup, 'bun')
        uses: oven-sh/setup-bun@v2

      - name: Build Archive (Unsigned)
        run: |
          # Capture root path to ensure archive goes to the right place regardless of cd
          WORK_DIR=$(pwd)
          ARCHIVE_PATH="$WORK_DIR/dist/build/App.xcarchive"
          mkdir -p "$WORK_DIR/dist"
          
          # Run setup commands (Bun build) if defined
          if [ ! -z "${{ matrix.setup }}" ]; then
             echo "Running setup commands..."
             ${{ matrix.setup }}
          fi

          # Change subdirectory if defined (e.g., cd Jacob)
          if [ ! -z "${{ matrix.subdir }}" ]; then
             echo "Changing directory to ${{ matrix.subdir }}"
             cd "${{ matrix.subdir }}"
          fi

          xcodebuild -scheme "${{ matrix.scheme }}" \
            -sdk iphoneos \
            -configuration Release \
            archive \
            -archivePath "$ARCHIVE_PATH" \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            -quiet

      - name: Extract Metadata & Icon
        id: metadata
        run: |
          # Note: We use the absolute path or relative to root. 
          # Since the previous step used absolute path for output, 
          # the archive is at ./dist/build/App.xcarchive in the workspace root.
          
          APP_BUNDLE_PATH="./dist/build/App.xcarchive/Products/Applications/${{ matrix.scheme }}.app"
          INFO_PLIST="$APP_BUNDLE_PATH/Info.plist"
          
          VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$INFO_PLIST")
          BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$INFO_PLIST")
          DISPLAY_NAME=$(/usr/libexec/PlistBuddy -c "Print :CFBundleDisplayName" "$INFO_PLIST" 2>/dev/null || /usr/libexec/PlistBuddy -c "Print :CFBundleName" "$INFO_PLIST")
          
          COMMIT_HASH=$(git rev-parse --short HEAD)
          COMMIT_MSG=$(git log -1 --pretty=%s | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          
          find "$APP_BUNDLE_PATH" -name "AppIcon*.png" | sort -r | head -n 1 > icon_path.txt
          ICON_SRC=$(cat icon_path.txt)
          
          if [ -z "$ICON_SRC" ]; then
             echo "No raw icon found. using placeholder."
             touch dist/icon.png
          else
             cp "$ICON_SRC" dist/icon.png
          fi

          cat <<EOF > dist/metadata.json
          {
            "name": "$DISPLAY_NAME",
            "bundleIdentifier": "$BUNDLE_ID",
            "version": "$VERSION",
            "scheme": "${{ matrix.scheme }}"
          }
          EOF
          
          python3 -c "import json; f='dist/metadata.json'; d=json.load(open(f)); d.update({'commitHash': '$COMMIT_HASH', 'commitMsg': '$COMMIT_MSG'}); json.dump(d, open(f,'w'))"

      - name: Package IPA
        env:
          ZIP_PASS: ${{ secrets.PROJECT_7_TOKEN }}
        run: |
          cd dist
          mkdir -p Payload
          cp -r ./build/App.xcarchive/Products/Applications/${{ matrix.scheme }}.app ./Payload/
          
          zip -r ./${{ matrix.scheme }}.ipa ./Payload
          
          zip -P "$ZIP_PASS" -r bundle.zip ${{ matrix.scheme }}.ipa metadata.json icon.png
          
          rm -rf Payload build ${{ matrix.scheme }}.ipa metadata.json icon.png

      - name: Upload Encrypted Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ matrix.scheme }}
          path: dist/bundle.zip
          retention-days: 1

  publish:
    name: Publish
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    
    steps:
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: ${{ env.ARTIFACT_PATTERN }}
          merge-multiple: false

      - name: Decrypt Artifacts
        env:
          ZIP_PASS: ${{ secrets.PROJECT_7_TOKEN }}
        run: |
          for app_dir in artifacts/*/; do
            if [ -f "${app_dir}bundle.zip" ]; then
              echo "Decrypting inside $app_dir..."
              (
                cd "$app_dir"
                # Unzip with password
                unzip -P "$ZIP_PASS" bundle.zip
                rm bundle.zip
              )
            fi
          done

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Generate Source & Prepare
        env:
          FOLDER_PASS: ${{ secrets.PROJECT_7_PASSWORD }}
        run: |
          cat << 'EOF' > gen_altstore.py
          import os
          import json
          import shutil
          from datetime import datetime, timezone
          
          root_url = os.environ["TARGET_BASE_URL_ROOT"]
          folder_pass = os.environ["FOLDER_PASS"]
          dev_name = os.environ["DEVELOPER_NAME"]
          
          output_dir = os.path.join("release_dist", folder_pass)
          os.makedirs(output_dir, exist_ok=True)
          
          target_url = f"{root_url}/{folder_pass}"
          
          source_json = json.loads(os.environ["SOURCE_JSON_BASE"])
          
          artifacts_root = "artifacts"
          folders = sorted(os.listdir(artifacts_root)) if os.path.exists(artifacts_root) else []
          
          for artifact_folder in folders:
              folder_path = os.path.join(artifacts_root, artifact_folder)
              if not os.path.isdir(folder_path): continue
                  
              meta_file = os.path.join(folder_path, "metadata.json")
              if not os.path.exists(meta_file): continue
                  
              with open(meta_file, "r") as f:
                  meta = json.load(f)
              
              scheme = meta["scheme"]
              ipa_filename = f"{scheme}.ipa"
              icon_filename = f"{scheme}.png"
              
              ipa_src = os.path.join(folder_path, ipa_filename)
              icon_src = os.path.join(folder_path, "icon.png")
              
              if os.path.exists(ipa_src):
                  shutil.copy2(ipa_src, os.path.join(output_dir, ipa_filename))
                  
                  final_icon_url = ""
                  if os.path.exists(icon_src) and os.path.getsize(icon_src) > 0:
                      shutil.copy2(icon_src, os.path.join(output_dir, icon_filename))
                      final_icon_url = f"{target_url}/{icon_filename}"
                  else:
                      final_icon_url = f"{target_url}/default_icon.png"

                  commit_msg = meta.get("commitMsg", "Update")
                  commit_hash = meta.get("commitHash", "unknown")
                  
                  # Dates
                  now = datetime.now(timezone.utc)
                  date_str = now.strftime("%Y-%m-%d") # Standard date
                  iso_date_str = now.strftime("%Y-%m-%dT%H:%M:%SZ") # ISO format for versions
                  
                  version_desc = f"{commit_msg} ({commit_hash})\nUpdated: {date_str}"
                  file_size = os.path.getsize(ipa_src)
                  
                  # Create the main entry including the versions array
                  app_entry = {
                      "name": meta['name'],
                      "bundleIdentifier": meta['bundleIdentifier'],
                      "developerName": dev_name,
                      "version": meta['version'],
                      "versionDate": date_str,
                      "versionDescription": version_desc,
                      "downloadURL": f"{target_url}/{ipa_filename}",
                      "localizedDescription": f"{meta['name']} by {dev_name}",
                      "iconURL": final_icon_url,
                      "size": file_size,
                      "versions": [
                          {
                              "version": meta['version'],
                              "date": iso_date_str,
                              "localizedDescription": version_desc,
                              "downloadURL": f"{target_url}/{ipa_filename}",
                              "size": file_size
                          }
                      ]
                  }
                  source_json["apps"].append(app_entry)
                  print(f"Processed {meta['name']}")
          
          with open(os.path.join(output_dir, "apps.json"), "w") as f:
              json.dump(source_json, f, indent=2)
          EOF
          
          python3 gen_altstore.py

      - name: Force Push to Target Repo
        env:
          API_TOKEN_GITHUB: ${{ secrets.PROJECT_7_TOKEN }}
        run: |
          cd release_dist
          git init
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          git checkout -b main
          git add .
          git commit -m "Deploy Apps: $(date)"
          
          git remote add origin https://x-access-token:$API_TOKEN_GITHUB@github.com/$TARGET_REPO.git
          git push -u --force origin main

      - name: Cleanup Artifacts
        if: always()
        uses: geekyeggo/delete-artifact@v5
        with:
          name: ${{ env.ARTIFACT_PATTERN }}
          failOnError: false
